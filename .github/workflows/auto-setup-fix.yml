name: Auto Setup and Fix System

on:
  workflow_dispatch:

env:
  AWS_REGION: us-east-1
  AWS_ACCOUNT_ID: 507297234735
  ECR_REPOSITORY: field-service-backend
  ECS_CLUSTER: field-service-cluster
  ECS_SERVICE: field-service-backend
  S3_BUCKET: field-service-frontend-prod

jobs:
  auto-setup-and-fix:
    name: Auto Setup Infrastructure and Fix Communication
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Check and setup missing infrastructure
        run: |
          echo "ðŸ” CHECKING EXISTING INFRASTRUCTURE..."
          echo ""
          
          # Check ECS Cluster
          echo "ðŸ“‹ Checking ECS Cluster..."
          CLUSTER_EXISTS=$(aws ecs describe-clusters \
            --clusters $ECS_CLUSTER \
            --region $AWS_REGION \
            --query 'clusters[0].clusterName' \
            --output text 2>/dev/null || echo "None")
          
          if [ "$CLUSTER_EXISTS" = "None" ]; then
            echo "âŒ ECS Cluster not found - creating..."
            aws ecs create-cluster --cluster-name $ECS_CLUSTER --region $AWS_REGION
            echo "âœ… ECS Cluster created: $ECS_CLUSTER"
          else
            echo "âœ… ECS Cluster exists: $ECS_CLUSTER"
          fi
          
          # Check ECR Repository
          echo ""
          echo "ðŸ“‹ Checking ECR Repository..."
          REPO_EXISTS=$(aws ecr describe-repositories \
            --repository-names $ECR_REPOSITORY \
            --region $AWS_REGION \
            --query 'repositories[0].repositoryName' \
            --output text 2>/dev/null || echo "None")
          
          if [ "$REPO_EXISTS" = "None" ]; then
            echo "âŒ ECR Repository not found - creating..."
            aws ecr create-repository --repository-name $ECR_REPOSITORY --region $AWS_REGION
            echo "âœ… ECR Repository created: $ECR_REPOSITORY"
          else
            echo "âœ… ECR Repository exists: $ECR_REPOSITORY"
          fi
          
          # Check IAM Role
          echo ""
          echo "ðŸ“‹ Checking ECS Task Execution Role..."
          ROLE_EXISTS=$(aws iam get-role \
            --role-name ecsTaskExecutionRole \
            --query 'Role.RoleName' \
            --output text 2>/dev/null || echo "None")
          
          if [ "$ROLE_EXISTS" = "None" ]; then
            echo "âŒ ECS Task Execution Role not found - creating..."
            
            cat > trust-policy.json << EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": {
                  "Service": "ecs-tasks.amazonaws.com"
                },
                "Action": "sts:AssumeRole"
              }
            ]
          }
          EOF
            
            aws iam create-role \
              --role-name ecsTaskExecutionRole \
              --assume-role-policy-document file://trust-policy.json
            
            aws iam attach-role-policy \
              --role-name ecsTaskExecutionRole \
              --policy-arn arn:aws:iam::aws:policy/service-role/AmazonECSTaskExecutionRolePolicy
            
            echo "âœ… ECS Task Execution Role created"
          else
            echo "âœ… ECS Task Execution Role exists"
          fi
          
          # Check Security Group
          echo ""
          echo "ðŸ“‹ Checking Security Group..."
          VPC_ID=$(aws ec2 describe-vpcs \
            --filters "Name=is-default,Values=true" \
            --query 'Vpcs[0].VpcId' \
            --output text \
            --region $AWS_REGION)
          
          SG_ID=$(aws ec2 describe-security-groups \
            --filters "Name=group-name,Values=field-service-backend-sg" \
            --query 'SecurityGroups[0].GroupId' \
            --output text \
            --region $AWS_REGION 2>/dev/null || echo "None")
          
          if [ "$SG_ID" = "None" ]; then
            echo "âŒ Security Group not found - creating..."
            SG_ID=$(aws ec2 create-security-group \
              --group-name field-service-backend-sg \
              --description "Security Group for Field Service Backend" \
              --vpc-id $VPC_ID \
              --region $AWS_REGION \
              --query 'GroupId' \
              --output text)
            
            # Add rules
            aws ec2 authorize-security-group-ingress \
              --group-id $SG_ID \
              --protocol tcp \
              --port 3000 \
              --cidr 0.0.0.0/0 \
              --region $AWS_REGION
            
            aws ec2 authorize-security-group-ingress \
              --group-id $SG_ID \
              --protocol tcp \
              --port 80 \
              --cidr 0.0.0.0/0 \
              --region $AWS_REGION
            
            aws ec2 authorize-security-group-ingress \
              --group-id $SG_ID \
              --protocol tcp \
              --port 443 \
              --cidr 0.0.0.0/0 \
              --region $AWS_REGION
            
            echo "âœ… Security Group created: $SG_ID"
          else
            echo "âœ… Security Group exists: $SG_ID"
          fi
          
          echo "SECURITY_GROUP_ID=$SG_ID" >> $GITHUB_ENV
          
          # Check S3 Bucket
          echo ""
          echo "ðŸ“‹ Checking S3 Bucket..."
          if aws s3 ls s3://$S3_BUCKET > /dev/null 2>&1; then
            echo "âœ… S3 Bucket exists: $S3_BUCKET"
          else
            echo "âŒ S3 Bucket not found - creating..."
            aws s3 mb s3://$S3_BUCKET --region $AWS_REGION
            
            aws s3 website s3://$S3_BUCKET \
              --index-document index.html \
              --error-document index.html
            
            cat > bucket-policy.json << EOF
          {
            "Version": "2012-10-17",
            "Statement": [
              {
                "Effect": "Allow",
                "Principal": "*",
                "Action": "s3:GetObject",
                "Resource": "arn:aws:s3:::$S3_BUCKET/*"
              }
            ]
          }
          EOF
            
            aws s3api put-bucket-policy \
              --bucket $S3_BUCKET \
              --policy file://bucket-policy.json
            
            echo "âœ… S3 Bucket created and configured: $S3_BUCKET"
          fi

      - name: Build and deploy backend
        run: |
          echo "ðŸ”§ BUILDING AND DEPLOYING BACKEND..."
          cd backend
          
          # Create production environment
          cat > .env << EOF
          NODE_ENV=production
          PORT=3000
          HOST=0.0.0.0
          
          # Database Configuration - Supabase
          DATABASE_URL=postgresql://postgres:Pa\$\$.word99@db.nphuclchphpnqawzzueb.supabase.co:5432/postgres
          DB_SSL=true
          
          # Redis Configuration - Upstash
          REDIS_URL=https://fast-lionfish-42154.upstash.io
          UPSTASH_REDIS_REST_TOKEN=AaSqAAIncDIyNDI5YTFhOWFlMDI0YjMwOWRiOWM0ODlmZGVkYzE1NHAyNDIxNTQ
          
          # JWT Configuration
          JWT_SECRET=FSM2024_Ultra\$ecure_JWT_Key_For_Production_987654321!
          JWT_EXPIRES_IN=7d
          JWT_REFRESH_EXPIRES_IN=30d
          
          # CORS Configuration
          CORS_ORIGIN=http://localhost:3001,http://localhost:19006,http://$S3_BUCKET.s3-website-$AWS_REGION.amazonaws.com
          
          # Rate Limiting
          RATE_LIMIT_WINDOW_MS=900000
          RATE_LIMIT_MAX_REQUESTS=100
          
          # Logging
          LOG_LEVEL=info
          
          # SLA Configuration
          DEFAULT_SLA_MINUTES=240
          SLA_WARNING_THRESHOLD=0.8
          SLA_CRITICAL_THRESHOLD=0.95
          
          # Geolocation
          MAX_CHECK_IN_DISTANCE_METERS=100
          LOCATION_PING_INTERVAL_SECONDS=120
          EOF
          
          # Build and push Docker image
          ECR_REGISTRY=${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG=auto-deploy-${{ github.run_number }}
          
          echo "ðŸ—ï¸ Building Docker image..."
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          
          echo "IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV
          echo "âœ… Backend image built and pushed"

      - name: Create or update ECS service
        run: |
          echo "ðŸ”§ SETTING UP ECS SERVICE..."
          
          # Check if service exists
          SERVICE_EXISTS=$(aws ecs describe-services \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --region $AWS_REGION \
            --query 'services[0].serviceName' \
            --output text 2>/dev/null || echo "None")
          
          if [ "$SERVICE_EXISTS" = "None" ]; then
            echo "âŒ ECS Service not found - creating..."
            
            # Get subnets
            VPC_ID=$(aws ec2 describe-vpcs \
              --filters "Name=is-default,Values=true" \
              --query 'Vpcs[0].VpcId' \
              --output text \
              --region $AWS_REGION)
            
            SUBNETS=$(aws ec2 describe-subnets \
              --filters "Name=vpc-id,Values=$VPC_ID" \
              --query 'Subnets[*].SubnetId' \
              --output text \
              --region $AWS_REGION)
            
            SUBNET_LIST=$(echo $SUBNETS | tr ' ' ',')
            
            # Create task definition
            cat > task-definition.json << EOF
          {
            "family": "$ECS_SERVICE",
            "networkMode": "awsvpc",
            "requiresCompatibilities": ["FARGATE"],
            "cpu": "512",
            "memory": "1024",
            "executionRoleArn": "arn:aws:iam::$AWS_ACCOUNT_ID:role/ecsTaskExecutionRole",
            "containerDefinitions": [
              {
                "name": "backend",
                "image": "$IMAGE_URI",
                "portMappings": [
                  {
                    "containerPort": 3000,
                    "protocol": "tcp"
                  }
                ],
                "essential": true,
                "logConfiguration": {
                  "logDriver": "awslogs",
                  "options": {
                    "awslogs-group": "/ecs/$ECS_SERVICE",
                    "awslogs-region": "$AWS_REGION",
                    "awslogs-stream-prefix": "ecs",
                    "awslogs-create-group": "true"
                  }
                }
              }
            ]
          }
          EOF
            
            # Register task definition
            aws ecs register-task-definition \
              --cli-input-json file://task-definition.json \
              --region $AWS_REGION
            
            # Create service
            aws ecs create-service \
              --cluster $ECS_CLUSTER \
              --service-name $ECS_SERVICE \
              --task-definition $ECS_SERVICE \
              --desired-count 1 \
              --launch-type FARGATE \
              --network-configuration "awsvpcConfiguration={subnets=[$SUBNET_LIST],securityGroups=[$SECURITY_GROUP_ID],assignPublicIp=ENABLED}" \
              --region $AWS_REGION
            
            echo "âœ… ECS Service created: $ECS_SERVICE"
          else
            echo "âœ… ECS Service exists - updating..."
            
            # Get current task definition and update image
            CURRENT_TASK_DEF=$(aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --services $ECS_SERVICE \
              --region $AWS_REGION \
              --query 'services[0].taskDefinition' \
              --output text)
            
            aws ecs describe-task-definition \
              --task-definition "$CURRENT_TASK_DEF" \
              --region $AWS_REGION \
              --query 'taskDefinition' > current-task-def.json
            
            cat current-task-def.json | jq --arg IMAGE_URI "$IMAGE_URI" '
              .containerDefinitions[0].image = $IMAGE_URI |
              del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)
            ' > new-task-definition.json
            
            NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
              --region $AWS_REGION \
              --cli-input-json file://new-task-definition.json \
              --query 'taskDefinition.taskDefinitionArn' \
              --output text)
            
            aws ecs update-service \
              --cluster $ECS_CLUSTER \
              --service $ECS_SERVICE \
              --task-definition "$NEW_TASK_DEF_ARN" \
              --region $AWS_REGION
            
            echo "âœ… ECS Service updated with new image"
          fi

      - name: Wait for backend and get IP
        run: |
          echo "â³ Waiting for backend deployment..."
          
          # Wait for service to stabilize with manual polling
          for i in {1..30}; do
            SERVICE_STATUS=$(aws ecs describe-services \
              --cluster $ECS_CLUSTER \
              --services $ECS_SERVICE \
              --region $AWS_REGION \
              --query 'services[0].{Running:runningCount,Desired:desiredCount,Status:status}' \
              --output text)
            
            echo "Attempt $i/30 - Service status: $SERVICE_STATUS"
            
            if echo "$SERVICE_STATUS" | grep -q "1.*1.*ACTIVE"; then
              echo "âœ… Service is stable and running"
              break
            else
              if [ $i -eq 30 ]; then
                echo "âš ï¸ Service taking longer than expected, continuing..."
                break
              fi
              echo "â³ Waiting 20 seconds..."
              sleep 20
            fi
          done
          
          echo "âœ… Backend deployment stable"
          
          # Get backend IP
          TASK_ARN=$(aws ecs list-tasks \
            --cluster $ECS_CLUSTER \
            --service-name $ECS_SERVICE \
            --query 'taskArns[0]' \
            --output text \
            --region $AWS_REGION)
          
          NETWORK_INTERFACE_ID=$(aws ecs describe-tasks \
            --cluster $ECS_CLUSTER \
            --tasks $TASK_ARN \
            --region $AWS_REGION \
            --query 'tasks[0].attachments[0].details[?name==`networkInterfaceId`].value' \
            --output text)
          
          BACKEND_IP=$(aws ec2 describe-network-interfaces \
            --network-interface-ids $NETWORK_INTERFACE_ID \
            --query 'NetworkInterfaces[0].Association.PublicIp' \
            --output text \
            --region $AWS_REGION)
          
          echo "âœ… Backend IP: $BACKEND_IP"
          echo "BACKEND_IP=$BACKEND_IP" >> $GITHUB_ENV
          
          # Test backend
          echo "ðŸ” Testing backend health..."
          for i in {1..10}; do
            if curl -s -f "http://$BACKEND_IP:3000/health" > /dev/null; then
              echo "âœ… Backend is healthy!"
              break
            else
              echo "â³ Attempt $i/10 - waiting for backend..."
              sleep 15
            fi
          done

      - name: Build and deploy frontend
        run: |
          echo "ðŸ”§ BUILDING AND DEPLOYING FRONTEND..."
          
          # Install Node.js
          curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
          sudo apt-get install -y nodejs
          
          cd frontend-web
          
          # Create frontend config
          cat > .env.production << EOF
          VITE_API_URL=http://$BACKEND_IP:3000
          VITE_SOCKET_URL=http://$BACKEND_IP:3000
          VITE_APP_NAME=Field Service Manager
          NODE_ENV=production
          EOF
          
          echo "âœ… Frontend configuration:"
          cat .env.production
          
          # Build frontend
          npm install
          npm run build
          
          # Deploy to S3
          aws s3 sync dist/ s3://$S3_BUCKET --delete
          
          echo "âœ… Frontend deployed successfully"

      - name: System verification and summary
        run: |
          echo ""
          echo "ðŸŽ‰ âœ… COMPLETE SYSTEM SETUP AND DEPLOYMENT FINISHED!"
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "ðŸ“‹ COMPLETE SYSTEM STATUS:"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ðŸ”§ BACKEND:"
          echo "â€¢ IP Address: $BACKEND_IP"
          echo "â€¢ API URL: http://$BACKEND_IP:3000"
          echo "â€¢ Health Check: http://$BACKEND_IP:3000/health"
          echo "â€¢ ECS Service: $ECS_SERVICE (running)"
          echo ""
          echo "ðŸŒ FRONTEND:"
          echo "â€¢ Website: http://$S3_BUCKET.s3-website-$AWS_REGION.amazonaws.com"
          echo "â€¢ API Target: http://$BACKEND_IP:3000 âœ…"
          echo "â€¢ Deployment: Fresh and synchronized âœ…"
          echo ""
          echo "ðŸ’¾ DATABASES:"
          echo "â€¢ PostgreSQL: Supabase (operational)"
          echo "â€¢ Redis: Upstash (operational)"
          echo ""
          echo "â˜ï¸ AWS INFRASTRUCTURE:"
          echo "â€¢ ECS Cluster: $ECS_CLUSTER âœ…"
          echo "â€¢ ECR Repository: $ECR_REPOSITORY âœ…"
          echo "â€¢ Security Group: $SECURITY_GROUP_ID âœ…"
          echo "â€¢ S3 Bucket: $S3_BUCKET âœ…"
          echo "â€¢ IAM Role: ecsTaskExecutionRole âœ…"
          echo ""
          echo "ðŸ” LOGIN CREDENTIALS:"
          echo "â€¢ Email: admin@fieldservice.com"
          echo "â€¢ Password: admin123"
          echo ""
          echo "ðŸ’° MONTHLY COST: \$25 USD"
          echo ""
          echo "ðŸ§ª READY TO USE:"
          echo "1. Go to: http://$S3_BUCKET.s3-website-$AWS_REGION.amazonaws.com"
          echo "2. Login with admin credentials"
          echo "3. System is 100% operational!"
          echo ""
          echo "ðŸš€ COMPLETE SYSTEM IS NOW OPERATIONAL!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"