name: Update Backend CORS Configuration

on:
  workflow_dispatch:
    inputs:
      frontend_url:
        description: 'Frontend S3 URL to add to CORS'
        required: true
        default: 'http://field-service-frontend-prod.s3-website-us-east-1.amazonaws.com'
        type: string

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: field-service-backend
  ECS_CLUSTER: field-service-cluster
  ECS_SERVICE: field-service-backend

jobs:
  update-backend-cors:
    name: Update Backend CORS
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Update backend environment with CORS configuration
        run: |
          cd backend
          echo "Updating .env with CORS configuration for S3 frontend"
          
          # Update CORS_ORIGIN to include S3 frontend URL
          sed -i 's|CORS_ORIGIN=.*|CORS_ORIGIN=http://localhost:3001,http://localhost:19006,${{ inputs.frontend_url }}|g' .env
          
          echo "Updated .env CORS configuration:"
          grep CORS_ORIGIN .env

      - name: Build and push Docker image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: cors-fix-${{ github.sha }}
        run: |
          cd backend
          echo "Building Docker image with updated CORS configuration"
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "IMAGE_URI=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_ENV

      - name: Update ECS task definition
        run: |
          echo "Getting current task definition"
          TASK_DEFINITION=$(aws ecs describe-task-definition \
            --task-definition $ECS_SERVICE \
            --query 'taskDefinition' \
            --region $AWS_REGION)
          
          echo "Creating new task definition with updated image"
          NEW_TASK_DEFINITION=$(echo $TASK_DEFINITION | jq --arg IMAGE_URI "$IMAGE_URI" \
            '.containerDefinitions[0].image = $IMAGE_URI | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)')
          
          echo "Registering new task definition"
          NEW_TASK_DEF_ARN=$(echo $NEW_TASK_DEFINITION | aws ecs register-task-definition \
            --region $AWS_REGION \
            --cli-input-json file:///dev/stdin \
            --query 'taskDefinition.taskDefinitionArn' \
            --output text)
          
          echo "New task definition ARN: $NEW_TASK_DEF_ARN"
          echo "TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV

      - name: Update ECS service
        run: |
          echo "Updating ECS service with new task definition"
          aws ecs update-service \
            --cluster $ECS_CLUSTER \
            --service $ECS_SERVICE \
            --task-definition $TASK_DEF_ARN \
            --region $AWS_REGION
          
          echo "Waiting for service to stabilize..."
          aws ecs wait services-stable \
            --cluster $ECS_CLUSTER \
            --services $ECS_SERVICE \
            --region $AWS_REGION

      - name: Get updated backend IP
        run: |
          echo "Getting updated backend IP address"
          TASK_ARN=$(aws ecs list-tasks \
            --cluster $ECS_CLUSTER \
            --service-name $ECS_SERVICE \
            --query 'taskArns[0]' \
            --output text \
            --region $AWS_REGION)
          
          if [ "$TASK_ARN" != "None" ] && [ "$TASK_ARN" != "" ]; then
            TASK_DETAILS=$(aws ecs describe-tasks \
              --cluster $ECS_CLUSTER \
              --tasks $TASK_ARN \
              --region $AWS_REGION)
            
            NETWORK_INTERFACE_ID=$(echo $TASK_DETAILS | jq -r '.tasks[0].attachments[0].details[] | select(.name=="networkInterfaceId") | .value')
            
            if [ "$NETWORK_INTERFACE_ID" != "null" ] && [ "$NETWORK_INTERFACE_ID" != "" ]; then
              PUBLIC_IP=$(aws ec2 describe-network-interfaces \
                --network-interface-ids $NETWORK_INTERFACE_ID \
                --query 'NetworkInterfaces[0].Association.PublicIp' \
                --output text \
                --region $AWS_REGION)
              
              echo "‚úÖ CORS CONFIGURATION UPDATED!"
              echo ""
              echo "üìã UPDATED BACKEND INFORMATION:"
              echo "‚Ä¢ New Backend IP: $PUBLIC_IP"
              echo "‚Ä¢ Backend URL: http://$PUBLIC_IP:3000"
              echo "‚Ä¢ Health Check: http://$PUBLIC_IP:3000/health"
              echo ""
              echo "‚úÖ CORS NOW ALLOWS:"
              echo "‚Ä¢ ${{ inputs.frontend_url }}"
              echo "‚Ä¢ http://localhost:3001"
              echo "‚Ä¢ http://localhost:19006"
              echo ""
              echo "üß™ TEST THE SYSTEM:"
              echo "‚Ä¢ Frontend: ${{ inputs.frontend_url }}"
              echo "‚Ä¢ Login: admin@fieldservice.com / admin123"
              echo ""
              echo "üî• The frontend should now connect successfully!"
            else
              echo "‚ùå Could not get network interface ID"
            fi
          else
            echo "‚ùå No running tasks found"
          fi